policy_module(Policy, 1.0.0)


########################################
#
# Declarations
#

# importing other modules i.e. thats not declared locally.
# these are declared elsewhere but we need to use them in our
# policy for our domtain transition rule

gen_require(` type unconfined_t; role unconfined_r; ' )


# declare types
type Policy_t;

type Policy_exec_t;


# Process environments of programs that user process environments
#transition to are called application # domains, and the type of such a
#process is called a application domain type.
# defining Policy_t & Policy_exec_t as application domain types here.

application_domain(Policy_t, Policy_exec_t)


# some one in the user role can be in Policy domain

role unconfined_r types Policy_t;

# allow the domain transition

domtrans_pattern(unconfined_t, Policy_exec_t, Policy_t)



########################################
#
# Myapp local policy
#

# Allow the process to have an executable stack for Policy

bool allow_Policy_t_execstack true;
if ( allow_Policy_t_execstack ) {
allow Policy_t self:process execstack;
allow Policy_t self:process execmem;
}


# call to a abstracted rule its a macro4

files_exec_etc_files(Policy_t)


# Allow Policy_t read system network config

sysnet_read_config(Policy_t)

# Allow the Policy process to read and write to the calling users
#psudo terminal

userdom_use_inherited_user_ptys(Policy_t)



# Allow  Access Policy And create socket  

allow Policy_t self:tcp_socket { create setopt bind};


# this allows the caller to Bind tcp sockets to generic ports e.g.
#ports with type port_t


corenet_tcp_bind_generic_port( )

corenet_tcp_bind_generic_node(Policy_t)


allow Policy_t self:tcp_socket { read write accept listen};


